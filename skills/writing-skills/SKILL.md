---
name: writing-skills
description: 當建立新技能、編輯現有技能或在部署前驗證技能有效時使用
---

# 編寫技能

## 概述

**編寫技能就是將測試驅動開發應用於流程文件。**

**個人技能位於代理特定目錄（Claude Code 的 `~/.claude/skills`，Codex 的 `~/.codex/skills`）**

你編寫測試案例（帶有子代理的壓力場景），看著它們失敗（基線行為），編寫技能（文件），看著測試通過（代理遵守），然後重構（關閉漏洞）。

**核心原則：** 如果你沒有看著代理在沒有技能的情況下失敗，你不知道技能是否教了正確的東西。

**必要背景：** 你必須在使用此技能之前理解 hi-skills:test-driven-development。該技能定義了基本的紅-綠-重構循環。此技能將 TDD 調整為文件。

**官方指導：** 有關 Anthropic 官方技能編寫最佳實踐，請參閱 anthropic-best-practices.md。該文件提供額外的模式和指南，補充此技能中以 TDD 為重點的方法。

## 什麼是技能？

**技能**是經過驗證的技術、模式或工具的參考指南。技能幫助未來的 Claude 實例找到並應用有效的方法。

**技能是：** 可重複使用的技術、模式、工具、參考指南

**技能不是：** 關於你如何解決某個問題的敘述

## 技能的 TDD 映射

| TDD 概念 | 技能建立 |
|-------------|----------------|
| **測試案例** | 帶有子代理的壓力場景 |
| **生產程式碼** | 技能文件（SKILL.md） |
| **測試失敗（紅色）** | 代理在沒有技能的情況下違反規則（基線） |
| **測試通過（綠色）** | 代理在技能存在時遵守 |
| **重構** | 在保持遵守的同時關閉漏洞 |
| **先寫測試** | 在編寫技能之前執行基線場景 |
| **看著它失敗** | 記錄代理使用的確切合理化 |
| **最少程式碼** | 編寫解決那些特定違規的技能 |
| **看著它通過** | 驗證代理現在遵守 |
| **重構循環** | 找到新的合理化 → 堵住 → 重新驗證 |

整個技能建立過程遵循紅-綠-重構。

## 何時建立技能

**建立當：**
- 技術對你來說不是直覺明顯的
- 你會在各個專案中再次引用這個
- 模式廣泛適用（不是專案特定的）
- 其他人會受益

**不要建立為：**
- 一次性解決方案
- 其他地方有良好文件的標準實踐
- 專案特定的慣例（放在 CLAUDE.md 中）
- 機械約束（如果可以用 regex/驗證強制執行，就自動化它——把文件留給判斷調用）

## 技能類型

### 技術
帶有步驟的具體方法（condition-based-waiting、root-cause-tracing）

### 模式
思考問題的方式（flatten-with-flags、test-invariants）

### 參考
API 文件、語法指南、工具文件（office docs）

## 目錄結構

```
skills/
  skill-name/
    SKILL.md              # 主要參考（必要）
    supporting-file.*     # 只在需要時
```

**扁平命名空間** - 所有技能在一個可搜尋的命名空間中

**分開檔案用於：**
1. **重度參考**（100+ 行）- API 文件、全面語法
2. **可重複使用的工具** - 腳本、工具、範本

**保持內聯：**
- 原則和概念
- 程式碼模式（< 50 行）
- 其他一切

## SKILL.md 結構

**前置資料（YAML）：**
- 只支援兩個欄位：`name` 和 `description`
- 總共最多 1024 字元
- `name`：只使用字母、數字和連字號（沒有括號、特殊字元）
- `description`：第三人稱，只描述何時使用（不是做什麼）
  - 以 "Use when..." 開始以聚焦觸發條件
  - 包含具體症狀、情況和上下文
  - **絕不總結技能的流程或工作流程**（參見 CSO 部分了解原因）
  - 如果可能保持在 500 字元以下

```markdown
---
name: Skill-Name-With-Hyphens
description: Use when [specific triggering conditions and symptoms]
---

# 技能名稱

## 概述
這是什麼？1-2 句核心原則。

## 何時使用
[如果決定不明顯，小內聯流程圖]

帶有症狀和使用案例的項目符號列表
何時不使用

## 核心模式（用於技術/模式）
前後程式碼比較

## 快速參考
表格或項目符號用於掃描常見操作

## 實作
內聯程式碼用於簡單模式
連結到檔案用於重度參考或可重複使用的工具

## 常見錯誤
什麼出錯了 + 修復

## 真實世界影響（可選）
具體結果
```

## Claude 搜尋優化（CSO）

**對發現至關重要：** 未來的 Claude 需要找到你的技能

### 1. 豐富的描述欄位

**目的：** Claude 閱讀描述來決定為給定任務載入哪些技能。讓它回答："我現在應該閱讀這個技能嗎？"

**格式：** 以 "Use when..." 開始以聚焦觸發條件

**關鍵：描述 = 何時使用，不是技能做什麼**

描述應該只描述觸發條件。不要在描述中總結技能的流程或工作流程。

**為什麼這很重要：** 測試揭示當描述總結技能的工作流程時，Claude 可能會遵循描述而不是閱讀完整的技能內容。說 "任務之間的程式碼審查" 的描述導致 Claude 只做一次審查，即使技能的流程圖清楚地顯示了兩次審查（規格符合性然後程式碼品質）。

當描述被更改為只是 "Use when executing implementation plans with independent tasks"（沒有工作流程總結）時，Claude 正確地閱讀了流程圖並遵循了兩階段審查過程。

**陷阱：** 總結工作流程的描述建立了 Claude 會走的捷徑。技能本體成為 Claude 跳過的文件。

```yaml
# ❌ 不好：總結工作流程 - Claude 可能會遵循這個而不是閱讀技能
description: Use when executing plans - dispatches subagent per task with code review between tasks

# ❌ 不好：太多流程細節
description: Use for TDD - write test first, watch it fail, write minimal code, refactor

# ✅ 好：只有觸發條件，沒有工作流程總結
description: Use when executing implementation plans with independent tasks in the current session

# ✅ 好：只有觸發條件
description: Use when implementing any feature or bugfix, before writing implementation code
```

**內容：**
- 使用表示此技能適用的具體觸發器、症狀和情況
- 描述*問題*（競爭條件、不一致行為）而不是*語言特定症狀*（setTimeout、sleep）
- 保持觸發器與技術無關，除非技能本身是特定技術的
- 如果技能是特定技術的，在觸發器中明確表示
- 用第三人稱寫（注入到系統提示中）
- **絕不總結技能的流程或工作流程**

### 2. 關鍵詞覆蓋

使用 Claude 會搜尋的詞：
- 錯誤訊息："Hook timed out"、"ENOTEMPTY"、"race condition"
- 症狀："flaky"、"hanging"、"zombie"、"pollution"
- 同義詞："timeout/hang/freeze"、"cleanup/teardown/afterEach"
- 工具：實際命令、程式庫名稱、檔案類型

### 3. 描述性命名

**使用主動語態，動詞優先：**
- ✅ `creating-skills` 不是 `skill-creation`
- ✅ `condition-based-waiting` 不是 `async-test-helpers`

### 4. Token 效率（關鍵）

**問題：** getting-started 和頻繁引用的技能載入到每個對話中。每個 token 都很重要。

**目標字數：**
- getting-started 工作流程：每個 <150 字
- 頻繁載入的技能：總共 <200 字
- 其他技能：<500 字（仍然要簡潔）

## 流程圖使用

**只在以下情況使用流程圖：**
- 不明顯的決策點
- 你可能過早停止的流程迴圈
- "何時使用 A vs B" 決策

**絕不為以下使用流程圖：**
- 參考材料 → 表格、列表
- 程式碼範例 → Markdown 區塊
- 線性指令 → 編號列表
- 沒有語義意義的標籤（step1、helper2）

## 程式碼範例

**一個優秀的範例勝過許多平庸的**

選擇最相關的語言：
- 測試技術 → TypeScript/JavaScript
- 系統除錯 → Shell/Python
- 資料處理 → Python

**好的範例：**
- 完整且可執行
- 有很好的註解解釋為什麼
- 來自真實場景
- 清楚地展示模式
- 準備好調整（不是通用範本）

**不要：**
- 用 5+ 種語言實作
- 建立填空範本
- 寫人為的範例

你擅長移植——一個好的範例就夠了。

## 鐵律（與 TDD 相同）

```
沒有先失敗的測試就沒有技能
```

這適用於新技能和對現有技能的編輯。

在測試之前寫技能？刪除它。重新開始。
在沒有測試的情況下編輯技能？同樣的違規。

**沒有例外：**
- 不是為了"簡單的添加"
- 不是為了"只是添加一個部分"
- 不是為了"文件更新"
- 不要保留未測試的變更作為"參考"
- 不要在執行測試時"調整"
- 刪除意味著刪除

## 跳過測試的常見合理化

| 藉口 | 現實 |
|--------|---------|
| "技能明顯很清楚" | 對你清楚 ≠ 對其他代理清楚。測試它。 |
| "它只是一個參考" | 參考可能有缺口、不清楚的部分。測試檢索。 |
| "測試太過度了" | 未測試的技能有問題。總是。15 分鐘測試節省數小時。 |
| "如果出現問題我會測試" | 問題 = 代理不能使用技能。在部署之前測試。 |
| "測試太繁瑣" | 測試比在生產中除錯壞技能更不繁瑣。 |
| "我很有信心它很好" | 過度自信保證問題。無論如何都要測試。 |
| "學術審查就夠了" | 閱讀 ≠ 使用。測試應用場景。 |
| "沒時間測試" | 部署未測試的技能浪費更多時間稍後修復它。 |

**所有這些意味著：部署前測試。沒有例外。**

## 技能的紅-綠-重構

遵循 TDD 循環：

### 紅色：寫失敗測試（基線）

在沒有技能的情況下用子代理執行壓力場景。記錄確切的行為：
- 他們做了什麼選擇？
- 他們使用了什麼合理化（原文）？
- 哪些壓力觸發了違規？

這是"看著測試失敗"——你必須在編寫技能之前看到代理自然做什麼。

### 綠色：寫最少技能

編寫解決那些特定合理化的技能。不要為假設的案例添加額外內容。

用技能執行相同的場景。代理現在應該遵守。

### 重構：關閉漏洞

代理找到新的合理化？添加明確的反駁。重新測試直到防彈。

## 反模式

### ❌ 敘述範例
"在 2025-10-03 會話中，我們發現空的 projectDir 導致..."
**為什麼不好：** 太具體，不可重複使用

### ❌ 多語言稀釋
example-js.js、example-py.py、example-go.go
**為什麼不好：** 品質平庸，維護負擔

### ❌ 流程圖中的程式碼
```dot
step1 [label="import fs"];
step2 [label="read file"];
```
**為什麼不好：** 不能複製貼上，難以閱讀

### ❌ 通用標籤
helper1、helper2、step3、pattern4
**為什麼不好：** 標籤應該有語義意義

## 停止：在移動到下一個技能之前

**在編寫任何技能後，你必須停止並完成部署過程。**

**不要：**
- 批量建立多個技能而不測試每一個
- 在當前技能驗證之前移動到下一個
- 因為"批量處理更有效率"而跳過測試

**下面的部署清單對每個技能都是強制的。**

部署未測試的技能 = 部署未測試的程式碼。這是違反品質標準的。

## 技能建立清單（TDD 調整版）

**重要：使用 TodoWrite 為下面每個清單項目建立 todos。**

**紅色階段 - 寫失敗測試：**
- [ ] 建立壓力場景（紀律技能 3+ 組合壓力）
- [ ] 在沒有技能的情況下執行場景 - 逐字記錄基線行為
- [ ] 識別合理化/失敗的模式

**綠色階段 - 寫最少技能：**
- [ ] 名稱只使用字母、數字、連字號（沒有括號/特殊字元）
- [ ] YAML 前置資料只有 name 和 description（最多 1024 字元）
- [ ] 描述以 "Use when..." 開始並包含具體觸發器/症狀
- [ ] 描述用第三人稱寫
- [ ] 整個文件中的關鍵詞用於搜尋（錯誤、症狀、工具）
- [ ] 帶有核心原則的清晰概述
- [ ] 解決紅色階段中識別的特定基線失敗
- [ ] 程式碼內聯或連結到單獨檔案
- [ ] 一個優秀的範例（不是多語言）
- [ ] 用技能執行場景 - 驗證代理現在遵守

**重構階段 - 關閉漏洞：**
- [ ] 識別測試中的新合理化
- [ ] 添加明確的反駁（如果是紀律技能）
- [ ] 從所有測試迭代建立合理化表
- [ ] 建立危險信號列表
- [ ] 重新測試直到防彈

**品質檢查：**
- [ ] 只在決策不明顯時使用小流程圖
- [ ] 快速參考表
- [ ] 常見錯誤部分
- [ ] 沒有敘述講故事
- [ ] 支援檔案只用於工具或重度參考

**部署：**
- [ ] 使用 `/auto-commit` 提交技能並推送到你的 fork（如果配置了）
- [ ] 考慮透過 PR 貢獻回去（如果廣泛有用）

## 發現工作流程

未來 Claude 如何找到你的技能：

1. **遇到問題**（"測試是 flaky 的"）
2. **找到技能**（描述匹配）
3. **掃描概述**（這相關嗎？）
4. **閱讀模式**（快速參考表）
5. **載入範例**（只在實作時）

**為這個流程優化** - 把可搜尋的術語放在前面和經常。

## 底線

**建立技能就是流程文件的 TDD。**

相同的鐵律：沒有先失敗的測試就沒有技能。
相同的循環：紅色（基線）→ 綠色（寫技能）→ 重構（關閉漏洞）。
相同的好處：更好的品質，更少的驚喜，防彈的結果。

如果你對程式碼遵循 TDD，對技能也遵循它。這是應用於文件的相同紀律。
